<!----- Conversion time: 9.027 seconds.


Using this Markdown file:

1. Cut and paste this output into your source file.
2. See the notes and action items below regarding this conversion run.
3. Check the rendered output (headings, lists, code blocks, tables) for proper
   formatting and use a linkchecker before you publish this page.

Conversion notes:

* Docs to Markdown version 1.0β17
* Wed Feb 05 2020 17:39:31 GMT-0800 (PST)
* Source doc: https://docs.google.com/a/thundernixon.com/open?id=15ZiZOuxXrvCrrNfY9lYJhEze3ZW7ZbWpvXHwDjCMbpk
* This document has images: check for >>>>>  gd2md-html alert:  inline image link in generated source and store images to your server.
----->


<p style="color: red; font-weight: bold">>>>>>  gd2md-html alert:  ERRORs: 0; WARNINGs: 0; ALERTS: 5.</p>
<ul style="color: red; font-weight: bold"><li>See top comment block for details on ERRORs and WARNINGs. <li>In the converted Markdown or HTML, search for inline alerts that start with >>>>>  gd2md-html alert:  for specific instances that need correction.</ul>

<p style="color: red; font-weight: bold">Links to alert messages:</p><a href="#gdcalert1">alert1</a>
<a href="#gdcalert2">alert2</a>
<a href="#gdcalert3">alert3</a>
<a href="#gdcalert4">alert4</a>
<a href="#gdcalert5">alert5</a>

<p style="color: red; font-weight: bold">>>>>> PLEASE check and correct alert issues and delete this message and the inline alerts.<hr></p>


# **Recursive Processes & Origins**

*Built to maximize versatility, control, and performance, Recursive is a five-axis variable font. This enables you to choose from a wide range of predefined styles or dial in exactly what you want for each of its axes: `Monospace`, `Casual`, `Weight`, `Slant`, and `Italic`. Taking full advantage of variable font technology, Recursive offers an unprecedented level of flexibility, all from a single font file.*

In programming, _recursion_ is when a function calls itself, using its outputs as inputs to yield results that might not be possible through other means. Put another way, recursion is when an objects's definition contains a reference to itself.

Not only can recursion be a useful technique in coding, but it is also an entertaining concept to think about. It touches on ideas of infinity and forces the observer to shift their way of thinking. Because of this, recursion is a long-running topic for jokes in computer science. There are many rescursive names for software, like GNU (“GNU’s Not Unix”) and PHP (“PHP: Hypertext Preprocesser”). If you Google _<span style="text-decoration:underline;">recursion</span>_, Google asks, “Did you mean: _<span style="text-decoration:underline;">recursion</span>_?”

---

Naming a font is hard, because the name must not clash with any existing fonts. If two fonts have matching names, they won't work well on the same computer – and there are tens of thousands of existing font families. What's more, as simple as a font name is, it has an outsized impact on the marketing success of a very complex project. Beyond all that, a font name should ideally present enough of the unique characters in the font it names to give viewers a sense of what the font is.

And so, early on in the process of this type project, I was faced with a common dilemma: what should I call it? All the good names seemed to be taken by existing fonts or by popular software projects. But then, I started wondering whether there might be some kind of “recursive” name I could come up with. “If only there were some sort of _recursive_ name for this weird cursive font for code,” I thought. “Oh hey, wait a minute....”

_Recursive_ was a perfect name already. For one thing, I couldn’t find any existing fonts with the name. Better yet, it used key letters from a monospace font, with the wide `r` and `i`. And yes, it hinted at a font that was for computers, but based on human writing. But most importantly, it said something meaningful about the project itself: Recursive was used to build itself. 

That may sound strange at first, until you understand the process of type design. When a type designer works on a new design, they must “proof” it constantly – usually by printing out strings of text and marking aspects that need further work. For my project, I needed traditional proofing, but I also needed to understand how it worked (and how it needed improvement) in code editors and on the web.

Something that many people don’t realize about modern-day type design is that it’s just as much a development process as a design process (especially in new areas such as variable fonts). Complex font projects need Python scripts to facilitate design production, font building, and visual testing. Like any other form of code, this scripting is primarily done with monospace fonts in code editors. Moreover, making fonts for the web works a lot better if the type designer can test their questions directly on the web.

Therefore, in order for me to understand how my font felt to use in actual practice, one of the best things I could do was to code with it. The output became a visual tool of input – my process was recursive, in a sense particular to type design.

<p id="gdcalert1" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Recursive-Process0.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert2">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Recursive-Process0.png "image_tooltip")

## Background

Recursive began in January 2018 as my thesis project at <span style="text-decoration:underline;">KABK TypeMedia</span>, a masters degree for type design in The Hague, NL. Outside of type, my main interests in design are digital interaction and web development. Within type, one of my main interests is in <span style="text-decoration:underline;">variable fonts</span>, an emerging technology that offers new possibilities for all areas of typography – but with some of the most obvious potential benefits for the web. With Recursive, I wanted to explore how variable fonts might be able to maximize both utility and creativity on the web and in digital interfaces.

### An origin in painted letters

Growing up, I found a lot of satisfaction in drawing letters – starting with the logos and wordmarks of sports teams (the branding of the Denver Broncos will always be a personal favorite), then logos for made-up car brands, and finally flyers and T-shirt artwork for bands I played in. Eventually, I found my place in a graphic design course at the University of Minnesota, where I first began to realize that the scope of design was much bigger than letters.

That led me into visual design for software and web branding, which I did in different roles at IBM for 3 years. On the side, though, I kept growing my love of lettering, calligraphy, and type design. I gravitated towards brush script lettering by legends like Ken Barber and Neil Secretario and was mesmerized by signpainters who could accomplish similar styles at lightning speed – but I personally felt best using brushes and calligraphy pens as a tool to find ideas, then carefully redrawing letters to “clean up” those ideas.

One of my favorite styles of signpainting and brush-inspired lettering was a genre commonly referred to as _casual,_ including both casual script (connected script from a brush) and single-stroke casual (usually all-cap, disconnected letters). 

Single-stroke casual is comprised of just a few basic strokes which are fit together to create the alphabet. It is a foundational style for signpainters because it efficient to learn and to paint. Its letterforms are designed in such a way that is deliberately inbalanced & informal. Generally, letters are somewhat condensed, have curved stems, heavily slanted, include stroke connections that are left visibly unconnected, and have midpoints that are lower than the vertical center. These qualities allow a signpainter to avoid some of the aspects of letter shaping that can be most challenging and most painstaking to achieve: perfectly straight lines, strokes that meet without separation, optically-centered spines on the letter `S`, and perfectly symmetrical, round strokes on letters like `C`, `G`, and  `O`.

[ IMAGE OF PHOTOLETTERING CATALOG ]

There are seemingly endless examples of casual fonts from catalogs from the now-defunct type foundry Photo-Lettering, but the one that we see over-and-over today on buildings, packaging, and trucks is Dom Casual. In New York City, where I live, there are also many examples of diners, laundromats, and commercial vehicles with handpainted single-stroke casual. Certainly, part of what inspired me in making Recursive were my many nostalgic connections to the low-brow signage of many NYC, both in vinyl or in naïve lettering. However, what really drove me to explore the genre were the signpainters that doing beautiful work in the style, today.

To name just a few that everyone should know about: 

*   Gen Ramírez ([@genramirez](https://www.instagram.com/genramirez)) was one of my classmates at TypeMedia, and his constant excellent sign painting definitely inspired me to dig further into the subject matter and want to explore what my own casual alphabet might look like.
*   John Downer ([@downervolt](https://www.instagram.com/downervolt)) is an excellent signpainter and type designer who actively teaches workshops and posts beautiful work. I consider his single-stroke casual to be a sort of “canonical version” of the style.
*   Petra Dočekalová ([@petra.typo](https://www.instagram.com/petra.typo)) tends to use flat-tipped markers over brushes, but does excellent and inspiring script signage, creatively adapting historical scripts for modern purposes
*   Jakob Engberg ([@copenhagensigns](https://www.instagram.com/copenhagensigns/)) is someone I know very little about, but whose work I oggle constantly.
*   [TODO: I need to verify with each of these people that it I have their blessing to include them in this essay]

![alt_text](images/Recursive-Process1.png "image_tooltip")

With Recursive, I never wanted to create a copy of any one signpainter’s style, but rather had the goal of establishing my own style of casual alphabet. I did look to signpainters to understand the different basic approaches to the uppercase casual alphabet and to better understand how paint strokes _work_ (for example, how more paint and more brush pressure can yield softer stroke endings), and to push my understanding of how effective casuals can _feel_ (I love the warmth and energy delivered in a casual sign).

Beyond looking at the work of others, I spent time trying to understand brush writing myself through painting letters and stroke exercises. Rather than following existing casual fonts, I sought to learn the basics of casual capitals and then apply this approach to a roman lowercase on my own, with a special focus on retaining the openness, energy, and legibility of a well-painted uppercase. Despite my many experiments, I didn't have enough to get particularly good at signpainting, so I also found that sketching with a brush _pen_ was an extremely helpful way to explore my ideas and prototype the shaping of my own casual alphabet.

On the streets and in the shops of NYC (where I live), there are many anonymous examples of casual signpainting of both expert and amateur skill levels, and as I have reworked Recursive in the time since TypeMedia, these examples have been some of the most inspiring to me.

<p id="gdcalert2" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Recursive-Process1.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert3">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>

### Starting with Mono


During the first semester of TypeMedia, we studied many areas of practice in type design, from stone carving to type revival to Python scripting. On the side, I wondered what my second-semester thesis project might be. As I sketched possibilities, two things caught my attention about single-stroke casuals: they looked super fun when stretched into extremely condensed and extremely wide styles, but to me they looked especially awesome when fit into the confines and contortions of monospaced letters.

Monospaced or “fixed-width” fonts are designed with the same amount of width for every character. They were originally created for typewriters, but have since become the standard for a wide variety of typographic tasks, from license plates to data visualization to computer code. With my background in web design & development and my love of casual letters, I got instantly hooked on the idea of a single-stroke casual monopace font for code. What might a casual for code look like? I couldn’t get the question out of my head, so I started drawing.

Most typefaces with both sans-serif and monospace variants are first designed to be proportional (with each letter taking up its “natural” width) and later adapted into fixed-width design (narrow letters are made wide, and wide letters are made narrow). With Recursive, I wondered what might happen if I started with a mono, and adapted this into a sans. I wasn’t the first designer to do this, but because I love the shape of monospace letters and was particularly drawn to how casual letters look on monospace shapes, it felt natural to go in this direction.

It was a decision that helped me to choose overall glyph metrics early on – a process which requires quite a lot of attention at the start of a typical type project. (I chose to follow the 10-letters-per-inch standard popularized by Courier and followed by many monospace fonts, from Bitstream Vera to IBM Plex Mono.) In turn, having early clarity on sizing allowed me to focus on what the specific shaping of my “brush strokes” ought to be. Most importantly, it helped me stumble upon possibilities that I probably would have missed, had I chosen to work in the traditional sans-to-mono direction.

### Two voices: serious and playful 


From the start, I wanted my project to have a “typographic” voice rather than to be a copy of any actual brush lettering, because I wanted it to work well in code, on screens. Still, finding this _exact_ voice was very difficult. What if something casual ending up being _too_ casual for some coders? In my own experience, there are monospace fonts that I love the look of for posters, but which I don’t find appealing to code with. When I code, I need to focus, and I don’t want to get too distracted by a fun font. But in some contexts such as documentation or while I’m using the terminal, I _do_ want my code to be fun & casual, at which times a workhorse mono can feel cold & bland.

This was a contradiction I realized from some of my earliest sketches, and solving it with a variable axis became a defining feature of the design. What might be two ends of a continuous spectrum that could be different enough to be striking counterparts but still entirely compatible for interpolation, and yet both work effectively at text sizes?

The Casual side of Recursive had some fairly direct inspiration in my interpretation of casual signpainting, but simplified for use at text sizes. The Linear side, on the other hand, had a slightly less-direct source. In my earliest sketches, I was trying to simply make the Casual sharper and low-contrast, without changing the overall “skeleton” too much. Ultimately, though, I found an odd source of inspiration: Verdana, a font designed by Matthew Carter as a text and interface font for the screens of the early 1990s … but today often found at huge sizes in store-front signage. When Verdana is enlarged for signage, it makes me cringe: the tiny flat ends of strokes get blown up to a disturbing degree, and it feels stiff and awkward. Still, the more I noticed these sorts of signs, I started to realize: with the Casual, I was already taking a style meant for signage and drawing it for screens – what if I took a style meant for screens and used for signage, but brought that back? This led to drawing with the “humanist” construction of Verdana, but with extra-large flattened points. I also wanted to increase the overall spacing inside and between letters, so I took after modern fonts like SF Compact by Apple and Input by David Jonathan Ross, and added portions of vertical straightness to the sides of round letters.



*   [image(s) of Verdana signage]

One advantage to having a spectrum of expression within a single typeface: it makes visually-rich design easy and fun. Some of the most compelling graphic design uses multiple, contrasting fonts. However, doing so effectively can be a very difficult design task for a designer. First, you must select two fonts that are different but have _something_ in common enough to harmonize. Then, you must control the sizing and layout of both fonts so that they _can_ work together – something that is hard enough in desktop design apps, but can be even more of a pain on the web. Recursive, by contrast, maintains similar metrics throughout the whole system. Setting a Mono Casual Medium code snippet inline with Sans Linear Regular text is simple – it just works! Experimenting with different styles for different aspects of a design is liberating – so long as you keep an element’s proportion (`MONO` axis) consistent, all other variation axes can be changed without that text changing width or reflowing at all. Not bad!



*   [Flip images comparing the two]

### Sans


Recursive’s _Casual _axis gives users the ability to change their typography from serious to fun, and allows for a greater range of typographic voices. But obviously, if a typeface only is only comprised of monospace styles, it can only really be useful for a narrow set of tasks. So, early in the course of the project, I knew that I wanted to adapt my fixed-width font to make a proportional companion. Proportional fonts are what we see most of the time: all letters have a “natural” width – the `i` is narrow while the `w` is wide, and so on. To be useful as a general typeface in blogs, software UI, websites, and more, Recursive needed proportional styles. 

Whereas most Sans & Mono type families would start as a Sans and be adapted into a Mono, working in the opposite direction for Recursive allowed me to find an opportunity to make a Sans that offered unique possibilities for interactive design. 

Before moving into type design, I worked as a visual designer for websites and software. In these roles, one of my primary areas of focus was typographic clarity and _microinteractions – _details of how interface elements respond to user interaction with subtle animations such as color, size, and position changes, in order to enhance the experience of products. In this work, I became familiar with details in fonts that worked – or didn't – for microinterations. 

With most fonts, it is possible to animate the color or position – but never the weight or slant. Not only are traditional static fonts unable to smoothly transition between weights, but even variable versions of those fonts present a problem in this type of animation: changing styles changes word shapes and line lengths. In turn, this risks breaking UI elements or causing unexpected line wrapping, and at best, it just looks janky.

But what if a font _didn’t_ change widths when it changed styles? Just as a monospace font must maintain the same widths for letters between all weights and styles, I realized that a Sans could do the same thing: letters could have natural widths, but they could also keep the _same_ widths between all stylistic variations. This isn’t a theory I invented from scratch: just as monospacing was originally a mechanical solution for typewriters, “duplexing” was commonly used in the past on old Linotype printing machines, which could only handle a limited set of character widths at one time. As you might be able to guess, the term “duplex” tends to describe 2 fonts with shared glyph widths, whereas there are 32 instances of Recursive Sans (and near-infinite variations between these), with shared glyph widths _and_ shared kerning, to ensure shared line lengths and allow smooth transitions between styles. So, I find it more accurate to says that Recursive is “superplexed.”



*   Image: [https://en.wikipedia.org/wiki/Metro_(typeface)#/media/File:Metrolite_and_Metroblack.jpg](https://en.wikipedia.org/wiki/Metro_(typeface)#/media/File:Metrolite_and_Metroblack.jpg)
*   Talk about semi-proportional approach

This being a process essay, it’s worth revealing a secondary benefit of making a superplexed Sans: it was a big boost for the project’s productivity. Instead of making Recursive Sans “from scratch,” my first attempts were in replacing just the clearly-distorted letters with more-natural options. At first, the `i` and `l` were 50% width while the `m` and `w` were 150% width. However, only changing these few characters had an unclear benefit. There are certainly fonts that do this, but my teachers at TypeMedia kept asking difficult questions: “Why have you stopped at just a few letters? What about letters that need to be somewhere in the middle, like `r` and `t`?” I found the answer in my UI design background. 

In UI, a very useful technique is working with an _[8-point grid](https://spec.fm/specifics/8-pt-grid). _Doing so is a deceptively simple change that makes a huge difference in personal and team productivity, as it offers enough flexibility to create nuanced layouts, but speeds up decisions eliminates guesswork. For Recursive, I embraced this spirit of efficiency in chose to base glyph widths on a grid. 

The underlying coordinate grid of Recursive is 1000 units, from descenders to ascenders. I split this into 20 divisions of 50 units each, and based my glyph widths on this. Instead of wondering whether to adjust glyphs to arbitrary widths, I could ask myself, “Should this `t` be 450, 500, or 550 units wide?” At this resolution, many glyphs from the Mono style didn’t really need to change widths at all, but the ones that did were adjusted. In the end, about half of the core Latin alphabet was adjusted in sans styles (along with most small punctuation and a few important symbols like @ and horizontal arrows). This may seem like a shortcut, and it was! But also, it offers many typographic benefits (example: currency symbols will keep orderly columns in financial data) and a massive amount of visual range into a relatively small overall filesize (one of the simplest and biggest benefits of variable fonts on the web).


    _¹UPM (Units Per eM) is the coordinate grid underlying the drawing of digital fonts. Outlines are drawn by points placed on this grid, e.g. you could draw a vertical line from  (x=50, y=250) to (x=50, y=500)._



*   Image: glyphs shared between mono & sans styles
*   Animation: Flip images comparing the sans and mono (how sans comes from mono)
    *   Letter shaping: r, f, i series in mono, mono italics, sans and sans italic
    *   Talking about how to make ideal spacing in either style

~~Technically, “Sans” is a term describing the lack of serifs in a typeface (as in _sans-serif_). As a result, I am often asked why the proportional instances of Recursive are called “Sans.” The answer is simple: that’s how I believe most developers think about fonts, which is codified by the typical CSS `font-family` fallback values: _serif, sans-serif, _and_ monospace._ Of course, I’m not the first type designer to have this idea – OHno has Covik Mono & Sans while DJR has Input Mono & Sans. ~~ _(Note: not sure this needs to be included.)_

### Design challenges


**Achieving variability **

Variable fonts are a fairly old idea, but have only become a real possibility for common production and usage in the past couple of years.



*   [TODO: summarize history of variable fonts, or better yet, find and link to a good article on it]

Because variable fonts are so new, the tools to design and build them are still in their infancy. Much of the work of Recursive has been in finding ways to make such a project possible – mostly in understanding tools made by others, like FontMake, FontTools, RoboFont, Skateboard, and Prepolator. But also, Recursive wouldn’t have been possible without a few brand-new tools and a lot of Python scripting.

Simply put, it takes a lot of time, effort, and skill to draw a single font well. Letters are drawn with bezier curves on a coordinate grid, which takes some getting used to. Of course, glyphs within a font must be stylistically harmonious with all the others, but even more importantly, they must be given the right proportions and spacing (margins on either side of each letter) to have a pleasing rhythm and be easy to read in text.

When a type designer creates a multi-weight family, they tend to draw only two or three “master” weights directly (also called _sources_), and then use _interpolation_ to generate in-between instances. Interpolation works by “averaging” the linear distance between points in masters. For instance, the coordinate points of a Medium weight might be approximately in the middle of Light and ExtraBold masters. The Regular weight is a bit thinner than that, and the SemiBold is a bit thicker, but these can be generated from the same two masters with slightly different values.



*   [GIF to make: light master, bold master, then in-between instances with dotted or partially-transparent outlines]

Interpolation has been common in type design for at least a couple of decades, and there are quite a few useful tools to help type designers in making fonts _compatible_ for interpolation. However, it is common for there to be a “post-processing” phase in the design of interpolated fonts. Masters are drawn, instances are generated, then everything is cleaned up a bit, with outline and metadata issues smoothed out before final font files are built as TTFs and OTFs for use.

In a variable font, interpolation is possible in the final output TTF or OTF, and controllable by the end use. This means that for the designer, there is no post-processing phase in which to clean up fonts before final output. As a result, it is a much greater challenge to make master fonts completely compatible – essentially, “compatibility” is a much higher bar to reach. In the production of static fonts, the masters can be _mostly_ matching and still be interpolated into acceptable intermediate instances. In the production of variable fonts, font data must match much more closely – anything different between masters will block the process. Each master _must_ be exactly matching in terms of: glyph sets, unicode values, offcurve points (also called “handles”), anchor points for diacritic placement, and more.

What’s more, whereas a font that has just a Weight axis probably requires two or three masters, each additional axis tends to double the amount of required masters. Between its axes Weight, Slant, Monospace, and Casual, Recursive requires _twenty-four _compatible masters, and each of these requires quite a few alternate glyphs to enable the Italic axis and the many OpenType features.



<p id="gdcalert3" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Recursive-Process2.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert4">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Recursive-Process2.png "image_tooltip")
 

<p id="gdcalert4" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Recursive-Process3.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert5">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Recursive-Process3.png "image_tooltip")


_Above, left: the 24 master drawings of the letter “m” \
Above, right: the 24 master drawings of the alternate glyph “m.italic”_

Beyond having quite a few source files, Recursive has a wide array of _diacritics_, or glyphs with accent marks, to support a extensive variety of languages that use the Latin script for writing. So, between different shaping of the letter “i” for Sans, Mono, and Italics, there are _actually_ 45 versions of the “i,” 14 different diacritic combinations built from `dotlessi`and diacritic components.



<p id="gdcalert5" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Recursive-Process4.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert6">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Recursive-Process4.png "image_tooltip")


Many books have been written on the design of type, and variable fonts will need their own books. Suffice to say, there is quite a bit of complexity to making 24 source fonts compatible, especially in Recursive, in which masters have over 1000 glyphs each. Luckily, there are helpful tools to manage this complexity!

Some of these tools are well-known and relatively well-established in the workflows of type designers building fonts for interpolation. RoboFont is my font editor of choice (especially for large and complex type projects). Prepolator is a very helpful 

During TypeMedia, my drawing was greatly assisted by early versions of _[MasterTools](https://github.com/RafalBuchner/masterTools),_ a tool built by my classmate Rafał Buchner. This tool helped with the small but essential task of counting oncurve and offcurve points and pointing out where there was a mismatch between masters. This year, MasterTools has since been greatly improved by Rafał, with sponsorship from Google Fonts. It is still being receiving improvements, but it remains an essential part of my workflow. 

Designing for interpolation isn’t just a technical challenge, however. It is also a fun game of strategy and  design: what shapes can be drawn with compatibility, and how can they be drawn  to enable the interpolated styles that look good in between? This question is relatively simple for a Weight axis: stroke  contrast changes from light to bold, but for the most part, things get thicker in a way that is familiar and easy to predict. But what about in an invented axis like _Casual_?

In the Casual axis, letterforms change in uncommon ways. Generally, shaping is optimized for legibility on the Linear side and optimized for personality on the Casual side. A few specific changes:



*   Stroke endings go from rectangular to softly-chiseled “brush strokes”
*   Round glyphs like `o` go from straight-sided to smoothly-curving
*   Diagonal glyphs like `v` get softly-curved sides
*   The joints of letters like `n` go from nearly perpendicular to nearly cursive
*   In the Slanted/Italic styles, stems go from straight to wavy
*   [TODO: make gif of how the points change in ExtraBold for letters “ovn”]

All of these changes must work with simple linear interpolation of each point, without looking bad from links or bumpy outlines in between. A moment of honesty: in my opinion, Recursive doesn’t look that good when casual is between 0 and 1 – it is more refined on the extremes. Does this mean the design failed? 

No, because there are still useful cases for flexibility between Linear and Casual styles! In use, a favorite technique of mine is giving a Casual transition to links on hover – it’s a subtle way to invite a user to click. At text sizes, “SemiCasual” styles are quite nice – highly legible, but not too serious. However, SemiCasual instances are deliberately excluded from production static fonts and named instances, because the others will look much better if used at large sizes and as the main styles for layout (as they are on this website).

**How to proof a font in infinite contexts**

A universal type design challenge not specific to variable fonts: knowing where design is and isn’t working well. This is largely done through proofing, the making of visual tests of a font in use in order to search for mistakes. Type designers spend many, many hours designing proofs, from spartan printouts of “spacing strings” all the way to full editorial or brand designs with their fonts. The latter provides helpful materials to include in marketing, and I certainly did a fair amount of this work. But also, I wanted to find a more efficient way to see how Recursive worked on real websites made by other people. The easy way to do this is to open of my browser’s Developer Tools and manually-edit the CSS of web pages. However, this is time consuming, takes repeated effort, and doesn’t really allow me to sit back and _experience _the font. To solve this, I made a simple Google Chrome extension that could override fonts on any webpage at the touch of a button, imposing my own font files onto those pages.

This year, with the help of <span style="text-decoration:underline;">@PixelAmbacht</span>, my basic (then slow and cumbersome) extension has evolved into [Type-X](https://github.com/arrowtype/type-x), a Chrome extension which allows users to override web fonts with any font on their system or to easily load in variable font files to test variable axes on real-world websites. This tool has applications far beyond Recursive and type design in general. Web designers and developers often need to test new fonts in their products, and Type-X makes this _way_ simpler than re-writing a codebase to try different options. Other times, users may just want to read a blog post or a Wikipedia entry with a nicer font – that’s easy, too.



*   Gif of Type-X

**Tuning the design details for release**



*   Forms of lowercase chosen especially for maximum ease of recognition, in both upright and italic forms. I avoided overly-cursive forms both to make something unique and to make something that anyone can read, without having to retrain their eyes.
*   Once I knew generally what the family should be, I had the chance to step back and work on other projects for a few months. 
    *   Coming back to it, I saw a bunch of opportunities of qualities to improve.
        *   Inktraps (gif of magnified difference - inktrap vs no inktrap. Take these in RF space center inverted, July 2018 vs Dec 2019)
        *   Overlaps reduced for improved pixel rendering
        *   Mathematical symmetry (GlyphMirror)
        *   “Wavy” casual italic stems
        *   (?) code ligatures as dlig \


As of July 2018, for my graduation from TypeMedia, Recursive was an extensive family, and I was mostly happy with the design, but knew of a few issues. I also had the benefit of stepping back and focusing on other projects, so I was able to see more opportunities for design improvement when I returned to the project in earnest, in Spring 2019.

At that point, I got the great opportunity of a commissioned from Google Fonts to finish and release the project with an OFL*. Better still, they were willing to hire a few people to help make the project successful. We hired a couple of my TypeMedia classmates, Lisa Huang and Katja Schimmel, to assist in finishing the (many) drawing tasks to make the font ready to release with an extended Latin character set. (It has been incredible collaborating with Lisa and Katja, and I am super grateful to them for applying their skill, care, and hard work to such a complex and strange project.)

*_OFL: SIL Open Font License, the standard license on almost all Google Fonts. It allows fonts to be duplicated, distributed, and modified almost without restriction – so long as any derivative work keeps the same OFL license._

**The basic structure**

Recursive is designed not only to be visually appealing, but also to maximize legibility (letter recognizability) and readability (overall spacing & flow) at small text sizes common to code and user interfaces. At a basic level, this meant that instead of designing a connected-script casual lowercase – as would often go with single-stroke casual uppercase – I designed a more-familiar Roman lowercase. At a deeper level, this goal led many specific decisions around the drawing and spacing of glyphs.

Rather than starting from the basis of a script, the lowercase of Recursive takes primary inspiration from “humanist sans” fonts such as Verdana and Bitstream Vera, keeping spacious counters, vertical terminals, and open apertures¹ in letters.

*counters: the inside whitespace of letters

*Terminals: the ending of strokes on letters like a, c, e, and s

¹ apertures: the openings in the counter shapes of letters like `a`, `e`, and `s`.



*   [diagram of letter construction – open counters, ]

Flat-sided curves in Recursive’s Linear styles borrow good ideas from fonts like SF Compact and Input. This design decision simultaneously allows letters to have ample counter space plus clear spacing, while maintaining recognizability. Meanwhile, the Casual styles round out these sides, keeping the visual center of curves lower than center for a handwritten, relaxed feel.



*   [diagram of round shapes vs flattened shapes, like in SF intro video]

**A big improvement from better outlines**

As previously mentioned, the Glyphs in a font are drawn with Bezier outlines. As with any complex technical pursuit, the drawing of these outlines is something that can seem simple and boring from the outside, but has hidden depth. How can you *really* draw outlines well? How can this process be efficient, leading to high-quality, interpolatable outlines with a reasonable input of time? What _are_ high-quality outlines, anyway?

There are many techniques and theories that go into the drawing of outlines for optimal glyph rendering. Largely, these techniques are ways to make outlines which are smoother (free from visual “lumps” or curves that seem uneven or otherwise out of place) and better at being rendered by hinting at small sizes on screens. Certainly, many hours of attention have gone into making the outlines in all styles of Recursive look and feel deliberate, confident, and precise.

While these aspects of outlines can be difficult to show, one aspect of Recursive’s outlines has changed greatly this year – and to great effect. 

During TypeMedia, I sought to capture brush-based signpainting relatively literally. In this pursuit, I built glyphs from multiple, overlapping strokes – aiming for a one-to-one match of Bezier contours and the brush strokes that would go into these shapes when painted with an actual, physical brush.

This approach had benefits. It kept me “honest” in my drawing, forcing me to maintain a clear visual connection between my inspiration and my implementation. It prioritize the _stroke_ of the tool as the source of truth for what the design should be (this was, in large part, influenced by ideas that are somewhat foundational to TypeMedia’s approach to education, from Gerrit Noordzij, as documented in his book, _[The Stroke](https://www.goodreads.com/book/show/487140.The_Stroke)_). Prioritizing the stroke, in turn, also allowed me to think about interpolation in a large system at a more elemental level than whole letters – I could consider how each stroke and terminal might exist and flex in combined axes. 

Breaking glyphs into one-contour-per-stroke also appealed to me conceptually. In _Concrete Mathematics, _Knuth, Graham, and Patashnik) say of _recurrent problems: _ “the solution to each problem depends on the solutions to smaller instances of the same problem” ([page 1](https://www.csie.ntu.edu.tw/~r97002/temp/Concrete%20Mathematics%202e.pdf)). I felt that by breaking the problem of interpolation down into strokes allowed me to approach it in a new way.

However, the approach had a serious flaw: it led to bad text rendering. How bad was the issue? On a high-DPI screen like a Retina or 4K monitor, it was nearly undetectable. But on a normal-DPI screen such as an Apple Thunderbolt or a typical 1080p, rendering included many visual “bumps” in outlines, which were most disruptive at text sizes. Somewhat humorously, I was the one student in my year of TypeMedia to be working on a 4K monitor – the Thunderbolt monitor at my desk had stopped working prematurely – so I largely missed the problem until using my font to code on a normal screen, _after_ graduation.

What caused the bumps? My knowledge of text rendering is limited, but basically, the subpixel antialiasing that is used to render glyph shapes accurately was rendering these overlaps separately, rather than together as single glyphs. This meant that where outlines overlapped, partially-darkened pixels would “double up” in value, leading to fully-dark pixels between partially dark pixels. 



*   Show an image of this effect

It was a large undertaking: all glyphs in Recursive were edited (more or less redrawn) to have overlaps only where strokes met at intersecting angles – never where strokes met at smooth exteriors of shapes. For anyone who is familiar with type design, it might seem that such work would only require a quick “remove overlaps” function to be run, but such an approach would have ruined compatibility by erasing hidden points on straight segments in many masters. So, the work was largely manual, but I was very lucky to have some help in finishing the typeface this year, and together with Katja and Lisa, simplifying outlines was one of the least-showy but most important updates to the family.

The approach of drawing with separate contours and subsequently unseparing them is not work I would voluntarily repeat in a future project, but I probably wouldn’t have been able to reach the same result without this unusual workflow. Luckily, redrawing for better rendering provided the opportunity to tune up shaping in several other ways, all of which added up to a typeface that is _far_ more mature and compelling than what I had before.

**Adding more flow and energy to the Casuals**

During my time designing Recursive at TypeMedia, I was seeking a way to imbue the Casual styles some of the softness and warmth I associate with casuals that are painted with a heavily-loaded paintbrush. I was trying to get past my earliest digital attempts that looked frustratingly like Bezier curves – cold, unconfident, and inconsistent. After some time away from Recursive, working on other projects, looking at more signs around NYC, and doodling more casuals with brush pens, I realized looking back at Recursive that its casuals were quite low-contrast*, which in turn made it a bit less dramatic and lively than I wanted it to be.

Additionally, I came to feel less certain of my TypeMedia conclusion that Italics should simply be sloped versions of the uprights, with few modifications. There is a wonderful forward curvature to single-stroke casuals when they are painted with a slant, and this becomes a waviness if they are written with a brush pen. I started exploring this, and I fell in love with the idea of having casuals that were relatively static and “typographic” when upright, but got a little wild when slanted. Doing so was also a bit of a type design in-joke: it is often said that Beziers should not be drawn with inflected curves*, as they are difficult to control. Indeed, some quality-checking tools flag inflected curves as an outline error. However, I found that with a bit of care, it was entirely possible to make stems that had inflected curves and which would interpolate quite nicely to and from straight, upright shapes.

During this process I also decided that, if I was going to be adding some more character to italics, I should push further on the scriptiness of the style. Whereas I previously only substituted a limited set of characters between roman and italic styles, I decided to swap almost all of the lowercase with true italic* glyphs. Once accented glyphs are taken into account, this became a larger scope than I had imagined at the start of the project, but between some scripting and some elbow grease, it worked! As before, I chose italic shapes that weren’t overly cursive – I want every letter in Recursive to be instantly and easily recognizable, without requiring readers to become used to reading traditional script forms.

* **Contrast:** the formal attribute of a letterform describing the differences in stroke thickness between thin and thick parts of the drawing. Fonts like Didot are high contrast, while fonts like Futura are very low contrast.

* **True Italics:** a description of italic letterforms that mimic handwriting, rather than simply slant the typical roman lowercase. This often includes shapes like a single-story `a` and `g`, an `f` with a tail, and rounded forms of diagonal glyphs like `v` and `w`.  

*** Inflected Curves: **Bezier curves that curve in one way, then another, without a control point at the part of the line that changes direction of curvature. 

**Tuning the Linears**

While designing this Casual/Linear family at TypeMedia, the instructors challenged me: how could I _really_ separate the Linear and Casual styles so they would be clearly different, if I wanted them to also interpolate well?

I found a fairly satisfactory answer in giving the Linear styles straight sides and simpler joints, but in the back of my head, I knew I could do better. The Linear styles still felt a bit “softer” and looser than I wanted.

I gave the Linear styles a more serious voice through three primary means:



1. Adding large inktraps* and increased contrast* to acute-angled joints
2. Making horizontal strokes a bit thinner to avoid a reverse-contrast appearance in text, from their low contrast
3. Ensuring stricter, more-mechanical symmetry to round and diagonal glyphs
*   gif of magnified linear style with inktraps and without

*Inktraps: added space in the meeting points of strokes in letters. Originally, these kept corners sharp when ink was squished slightly past the outlines of letters in small print – the extra room in corners “trapped ink.” In digital type, they serve a similar purpose at text sizes by keeping enough room in corners to make them clearly visible. 

It’s no surprise to anyone watching the font releases of the past few years that inktraps are a popular design motif. However, whereas these were once important to maintaining clear outlines in harsh print conditions, their main purpose today is arguably more aesthetic and less utilitarian – proven partly by their role in display-oriented typefaces like Colophon’s Space Monk and Dynamo’s Whyte Inktrap. In Recursive, inktraps serve dual purposes. At large font sizes or when text is looked at closely, the inktraps add a bit of visual complexity and a hint of industrial “finish” to letterforms. At text sizes, they allow a little extra light into corners, helping to reinforce and clarify the shaping of letters.

Almost all type is made with horizontal strokes drawn less thick than vertical stems – without this optical compensation, the horizontal strokes will look thicker than vertical strokes. When this flip is deliberately done, it is often termed as “reverse contrast.” In Recursive’s Casual styles, stroke contrast is barely compensated, and often is a reverse contrast, keeping in line with signpainted precedents. In Recursive’s Linear styles, however, a good bit more compensation was added to ensure that letters would look low-contrast but decidedly “normal.” Through using Recursive as my daily coding font, I found that the amount of compensation required at small scales is greater than the amount needed at larger sizes – probably due to the way text is rendered when only a few pixels are available. To counteract this, more contrast was added.

Many type designers will point out the many intuitive decisions and optical adjustments that go into their drawings. To be sure, this is an important aspect of type design. Too much reliance on simple geometry and copied-pasted shapes can be a mark of a poor design – in type, circles don’t look circular and mechanical symmetry often looks unbalanced, so a good designer must learn to see and correct these issues. That said, an easy trap to fall into is making overly-irregular type due to a lack of tools to make the right kinda of regularity possible.

In Recursive’s Linear styles, I was troubled by how often shapes lacked precise symmetry. A complex point structure is required to allow the full family’s variable interpolation, but this was making it difficult to make shapes properly mirrored. In particular, letters like `O`, `C`, and `D` lacked symmetry where I wanted it. In many designs, of course, these glyphs should not be symmetrical. In many other designs, they should be optically corrected to _look_ symmetrical. But, at a certain point, optical corrections can be subjective, and I wanted to remove subjectivity from these styles.

With this in mind, I commissioned one of my former TypeMedia classmates, Rafał Buchner, to build <span style="text-decoration:underline;">Glyph Mirror</span>, a RoboFont which draws a symmetrical image of the current glyph in the background, updating this with outline edits to make it a snap to achieve symmetry where desired. This is a seemingly small tweak to the experience of drawing, but it completely freed me to make properly-reflected curves where I wanted them. Like the other tools developed in relation to this project (and like Recursive itself), Glyph Mirror is free and open-source, so anyone can use it, learn from its code, and update it to suit their needs.

**One more thing: Code Ligatures**

Normally, a _ligature_ is a single unit of type made from two or more characters. Generally speaking, they exist to make text flow better, most often by fixing spacing problems from combinations such as “fi.” Sometimes, ligatures are purely decorative flourishes, as is the case in _discretionary ligatures_ such as a connected “ct” and “st” forms that are sometimes found in serif fonts.



*   [fi ligature vs ct ligature … maybe in crimson pro or Libre Caslon pro?]

 _Code ligatures_ are similar to other ligatures in that they are single units of type which represent multiple characters. They exist less to improve flow or spacing and much more as stylistic flourish, serving to connect and distinguish syntactically significant sequences of characters in code. 

Code ligatures are a controversial subject: many developers love them [link to twitter poll], while type designers tend to  either dismiss or outright despise them [link to butternick]. For Recursive, coders are my core intended users, so that’s who I’m making my design decisions for. Still, type designers who are concerned by code ligatures have a few good points, and I took these into account when designing this feature.



*   General concern: Code ligatures are confusing. Ligatures aren’t the right mechanism to use for syntax highlighting, anyway. They move around while you type, which is weird. 
    *   Background: code ligatures replace shapes with other shapes than can be quite different to the uninitiated (=== is relaxes by ===), and they are “on by default” in fonts that include them. The fact that they change shaping after being typed is a feature: they are an additional layer of syntax highlighting.
    *   Fix: Recursive use the OpenType feature **dlig** (Discretionary ligatures, which are off by default) to activate code ligatures, rather than **calt (**contextual alternates,  which are used in other code ligatures fonts, but actually meant to make script fonts work better). This is partly important so that users have a choice of whether they want code ligatures when using Recursive, especially in non-code situations such as apps and webpages.
*   Claim: "They contradict Unicode ... in a source file that uses Unicode characters, how would you know if you’re looking at a => ligature that’s shaped like ⇒ vs. Unicode character 0x21D2, which also looks like ⇒?
    *   Response: Code ligatures don't affect the actual unicode values of your code. Visually, the take up multiple with units, so it a monospace font, it is fairly clear when you have a single character versus multiple characters in a ligature. That said, if a user has three types of ⇒ in their code, I would suggest turning off code ligatures temporarily. Moreover, if a user is presenting code to others (especially to beginners, as in a video tutorial), I would prefer they don't use code ligatures, as these glyphs can type on sight.
*   Claim: "They’re guaranteed to be wrong sometimes. There are a lot of ways for a given sequence of characters, like “=>”, to end up in a source file. Depending on context, it doesn’t always mean the same thing."
    *   Response: I haven’t seen an actual example of this. How often would this appear, and how often would that be confusing? The OpenType feature code is written to ignore cases in which code ligatures appear in continuous strings of similar characters. If a user _does_ find an example in which a code ligature presents ambiguity, I would hope they file an issue, so it can be resolved with a font update.

The ones that like them can activate them with **dlig** (now supported by all major code editors)
**Closing thoughts: do variable fonts limit creativity?**</h3>


Variable fonts are still a relatively new technology, and many type designers and observers have expressed concerns around whether the format restricts creativity. “Fonts have become generic and boring,” they say, “and trying to make every glyph compatible between all styles will only make things worse.” They point to masterpieces of type history such as Monotype Grotesque which have very different shaping for letters in different styles, such as a “single-story” `g` in narrow styles but a “double-story” `g` in wide styles. If designers are required to draw shapes that can interpolate between different weights, widths, and styles, won’t this force the adoption of the same, boring shapes across whole type families?

With Recursive, a central goal has been to prove this concern wrong. If you spend time playing with the axes of Recursive, you’ll probably notice that glyph shapes change quite a bit from style to style. Some of these are smoothly compatible (but hardly boring), like the shift from a sturdy, familiar `m` (`CASL=0`) to a brushy version of the same letter (`CASL=1`), and much narrower versions of that same letter in Monospace instances (`MONO=1`). Other letters change more dramatically along the `MONO` axis: the `g` gains an “ear” in the mono style for improved recognizability, while letters like `i` and `l` gain bottom serifs to improve spacing with their extended widths. Meanwhile, shifting the `slnt` axis changes nearly all lowercase letters to a disconnected-cursive forms – a transformation that can be controlled with the `ital` axis. 

These radical differences in glyph shaping along stylistic axes can be achieved relatively easily, by a method called _glyph substitution. _The actual mechanics of how this works in OpenType fonts was devised by [people far smarter than me](https://github.com/fonttools/fonttools/graphs/contributors), but as a designer, I make this possible by drawing each form of a letter across all sources, then I simply specify which glyph should be displayed for which axis conditions. In the case of a glyph like `l`, I drew 24 versions of the “mono” shape: 12 for the actual Mono styles and 12 that were as narrow as a normal `l`. I also drew 24 of the “sans” shape: 12 for the actual Sans styles, and 12 that were as wide as a mono `l`. And then, in my build process, I specified that between 0.5 and 1.0 on the `MONO` axis, the `l.sans` must switch to `l.mono`. (I also drew 24 versions of `l.italic` to support the slnt/ital axes). Inconvenient? Perhaps. Impossible? Nope!

Another question I’ve been asked: did making so many compatible masters require me to compromise the design? This is a fair question, and the answer is both _yes_ and _no_. Recursive has received many, many hours of work and refinement, and each possible style is a pretty high quality. With the same amount of time, could I have produced something with more-perfect outlines and spacing, if it were only one or two styles? Of course – but it would have been a totally-different product. Beautifully-crafted, highly-focused typefaces will always have their place_, _but they are a different kind of product, offering a different kind of utility. Similarly, the experience of listening to music on a record player is unmatched by streaming songs from a smartphone. The smartphone is made to have many good features rather than doing any one thing perfectly – but often, the smartphone is pretty handy.

Design is finding an elegant way to satisfy constraints and solve problems. With Recursive, I aimed to produce a radically different kind of font within a limited amount of time. Making it into a final, production product has _still_ taken a lot more work from myself and my teammates than I expected at the outset, but we did it!

That said, Recursive is just _one possibility_ of what can be done with variable fonts. Many existing typefaces are possible to upgrade into weight-axis variable fonts, with little to no reworking required, and as a result, many fonts you already know will become variable fonts without you even noticing. And in the coming months, other type designers will be releasing incredible new variable font projects. The creativity that this new format is enabling in font design is, simply put, exhilarating. And the variable fonts that are being designed today will enable new kinds of creativity in graphic, web, and interaction design. 

The future of typography is bright!

—-----

### Thank you to...




*   Noemi Stauffer, for helping me to come up with a structure for this essay, and for helping to edit it down to something worth reading.
*   E Roon Kang, Minkyoung Kim, and Talia Cotton for collaborating in the designing and building of this project’s website
*   Dave Crossland, Rod Sheeter, Irin Kim, and the rest of the Google Fonts crew for believing in Recursive and making this wild project possible.
*   Lisa Huang and Katja Schimmel for their excellent contributions to the drawing of Recursive.
*   Ben Kiel for boldly taking on the type mastering for this huge, weird, evolving, technical, and boundary-pushing project, and for his mentorship and advice beyond that
*   Gen Ramirez, Seán Donohoe, and John Downer for sharing their knowledge of signpainting and single-stroke casual
*   House Industries for allowing me to use images of casual fonts from their Photo-Lettering archives
*   The KABK TypeMedia staff, faculty, and alumni for their education, support, critique, and encouragement in pushing me to pursue an ambitious project
*   My many heroes in type design who inspire me to draw new type, and  the smaller number of    heroes in type development who make it all possible

<!-- Docs to Markdown version 1.0β17 -->
